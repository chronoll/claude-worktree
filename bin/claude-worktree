#!/bin/bash

# Claude Tools CLI
# Usage: claude-tools <command> [options]

# Get repository information
get_repo_info() {
    local git_root
    git_root=$(git rev-parse --show-toplevel 2>/dev/null)
    
    if [ -z "$git_root" ]; then
        echo "Error: Not in a git repository"
        exit 1
    fi
    
    # Check if we're in the main repository or a worktree
    local current_dir=$(pwd)
    local main_repo_dir
    
    # Get the main repository directory from git worktree list
    main_repo_dir=$(git worktree list | head -1 | awk '{print $1}')
    
    if [ "$current_dir" = "$main_repo_dir" ]; then
        # We're in the main repository
        REPO_NAME=$(basename "$main_repo_dir")
        WORKTREE_BASE="../project-claude-${REPO_NAME}"
        IN_WORKTREE=false
    else
        # We're in a worktree - check if current directory is a worktree
        if git worktree list | grep -q "^${current_dir}\s"; then
            # We're in a worktree
            REPO_NAME=$(basename "$main_repo_dir")
            WORKTREE_BASE="./worktrees"
            IN_WORKTREE=true
            MAIN_REPO_DIR="$main_repo_dir"
        else
            # We're in a subdirectory - use normal logic
            REPO_NAME=$(basename "$git_root")
            WORKTREE_BASE="../project-claude-${REPO_NAME}"
            IN_WORKTREE=false
        fi
    fi
}

# Check if we're in a git repository
check_git_repo() {
    get_repo_info
}

# Show help message
show_help() {
    echo "Claude Worktree CLI - Worktree management for Claude Code"
    echo ""
    echo "Usage:"
    echo "  claude-worktree worktree <identifier>    Create new worktree and start Claude Code"
    echo "  claude-worktree list                     List all worktrees for this repository"
    echo "  claude-worktree switch <identifier>      Switch to existing worktree"
    echo "  claude-worktree help                     Show this help message"
    echo ""
    echo "Examples:"
    echo "  claude-worktree worktree netflix-clone   # Create and start new worktree"
    echo "  claude-worktree list                     # Show all worktrees"
    echo "  claude-worktree switch netflix-clone     # Switch to existing worktree"
}

# List worktrees for this repository with hierarchical display
list_worktrees() {
    check_git_repo
    
    echo "üìã Worktrees for repository: $REPO_NAME"
    echo ""
    
    # Get all worktrees from git, filtering out prunable ones and checking existence
    local valid_worktrees=""
    local temp_file=$(mktemp)
    git worktree list | tail -n +2 | grep -v " prunable" > "$temp_file"
    
    while IFS= read -r line; do
        [ -z "$line" ] && continue
        local worktree_path=$(echo "$line" | awk '{print $1}')
        # Only include worktrees that actually exist on disk
        if [ -d "$worktree_path" ]; then
            valid_worktrees+="$line"$'\n'
        fi
    done < "$temp_file"
    
    rm -f "$temp_file"
    
    if [ -z "$valid_worktrees" ]; then
        echo "No valid worktrees found. Create one with: claude-worktree worktree <identifier>"
        return
    fi
    
    # First, collect all worktrees and identify parent-child relationships
    local temp_output_file=$(mktemp)
    local displayed_parents_file=$(mktemp)
    
    # Process nested worktrees first to identify parents
    echo "$valid_worktrees" | while IFS= read -r line; do
        [ -z "$line" ] && continue
        local worktree_path=$(echo "$line" | awk '{print $1}')
        local branch=$(echo "$line" | awk '{print $3}' | tr -d '[]')
        local identifier=$(basename "$worktree_path")
        
        # Check if this is a nested worktree
        if [[ "$worktree_path" == */worktrees/* ]]; then
            # Extract parent worktree path
            local parent_path=$(echo "$worktree_path" | sed 's|/worktrees/.*||')
            local parent_name=$(basename "$parent_path")
            
            # Check if parent was already shown
            if ! grep -q "^${parent_name}$" "$displayed_parents_file" 2>/dev/null; then
                # Show parent worktree only if it exists in our valid list
                local parent_line=$(echo "$valid_worktrees" | grep "^${parent_path}\s")
                if [ -n "$parent_line" ]; then
                    local parent_branch=$(echo "$parent_line" | awk '{print $3}' | tr -d '[]')
                    echo "üåø $parent_name -> $parent_branch" >> "$temp_output_file"
                    echo "$parent_name" >> "$displayed_parents_file"
                fi
            fi
            
            # Show nested worktree with indentation and full path
            echo "  ‚îî‚îÄ‚îÄ üåø $parent_name/$identifier -> $branch" >> "$temp_output_file"
        fi
    done
    
    # Then process root level worktrees (non-nested)
    echo "$valid_worktrees" | while IFS= read -r line; do
        [ -z "$line" ] && continue
        local worktree_path=$(echo "$line" | awk '{print $1}')
        local branch=$(echo "$line" | awk '{print $3}' | tr -d '[]')
        local identifier=$(basename "$worktree_path")
        
        # Skip nested worktrees (already processed above)
        if [[ "$worktree_path" == */worktrees/* ]]; then
            continue
        fi
        
        # Check if this worktree has nested children
        local has_children=false
        if echo "$valid_worktrees" | grep -q "${worktree_path}/worktrees/"; then
            has_children=true
        fi
        
        # Only show root-level worktrees that don't have children (or parents already shown)
        if [ "$has_children" = "false" ]; then
            # Check if this was already displayed as a parent
            if ! grep -q "^${identifier}$" "$displayed_parents_file" 2>/dev/null; then
                echo "üåø $identifier -> $branch" >> "$temp_output_file"
            fi
        fi
    done
    
    # Output the results and cleanup
    cat "$temp_output_file" 2>/dev/null || echo "No worktrees found."
    rm -f "$temp_output_file" "$displayed_parents_file"
}

# Switch to existing worktree
switch_worktree() {
    local identifier="$1"
    
    if [ -z "$identifier" ]; then
        echo "Usage: claude-worktree switch <identifier>"
        echo "       claude-worktree switch <parent>/<child>  # for nested worktrees"
        echo "Use 'claude-worktree list' to see available worktrees"
        exit 1
    fi
    
    check_git_repo
    
    # Find worktree by identifier from git worktree list
    local worktree_dir
    local matches=()
    local main_repo_base="../project-claude-${REPO_NAME}"
    
    # Check if identifier contains a slash (hierarchical path)
    if [[ "$identifier" == *"/"* ]]; then
        # Hierarchical path - look for exact nested worktree match
        local parent_name=$(echo "$identifier" | cut -d'/' -f1)
        local child_name=$(echo "$identifier" | cut -d'/' -f2-)
        
        # Find the nested worktree - must match exact hierarchy
        worktree_dir=$(git worktree list | grep -E "/$parent_name/worktrees/$child_name\s" | awk '{print $1}' | head -1)
        
        if [ -z "$worktree_dir" ]; then
            echo "‚ùå Nested worktree '$identifier' not found"
            echo "Available worktrees:"
            list_worktrees
            echo ""
            echo "üí° Use exact hierarchical path: parent/child"
            exit 1
        fi
    else
        # Simple identifier - check context-aware matching
        check_git_repo
        
        # Check if we're currently in a worktree
        local current_dir=$(pwd)
        local current_worktree=""
        
        # Find current worktree from git worktree list (exact match)
        local main_repo_path=$(git worktree list | head -1 | awk '{print $1}')
        
        if [[ "$current_dir" == "$main_repo_path" ]]; then
            # We're in main repo, not in a worktree
            current_worktree=""
        else
            while IFS= read -r line; do
                local path=$(echo "$line" | awk '{print $1}')
                if [[ "$current_dir" == "$path" ]]; then
                    current_worktree="$path"
                    break
                fi
            done < <(git worktree list | tail -n +2)  # Skip main repo
        fi
        
        if [ -n "$current_worktree" ]; then
            # We're in a worktree - look for child worktrees first
            local current_name=$(basename "$current_worktree")
            local child_path="$current_worktree/worktrees/$identifier"
            
            if git worktree list | grep -q "$child_path\s"; then
                worktree_dir="$child_path"
                echo "üîó Found child worktree in current context"
            fi
        fi
        
        # If not found in current context, look for root-level worktrees
        if [ -z "$worktree_dir" ]; then
            while IFS= read -r line; do
                local path=$(echo "$line" | awk '{print $1}')
                local path_name=$(basename "$path")
                # Check if this matches the identifier and is a root-level worktree (not nested)
                if [[ "$path_name" == "$identifier" && ! "$path" == */worktrees/* ]]; then
                    matches+=("$path")
                fi
            done < <(git worktree list | tail -n +2)  # Skip main repo
            
            if [ ${#matches[@]} -eq 1 ]; then
                worktree_dir="${matches[0]}"
            elif [ ${#matches[@]} -gt 1 ]; then
                echo "‚ùå Multiple worktrees found for '$identifier':"
                for match in "${matches[@]}"; do
                    echo "   - $match"
                done
                echo ""
                echo "üí° Use full path to specify exact worktree"
                exit 1
            fi
        fi
        
        # Final check if nothing found
        if [ -z "$worktree_dir" ]; then
            echo "‚ùå Worktree '$identifier' not found"
            echo ""
            if [ -n "$current_worktree" ]; then
                local current_name=$(basename "$current_worktree")
                echo "üí° From $current_name, you can:"
                echo "   - Switch to child: claude-worktree switch <child-name>"
                echo "   - Switch to other: claude-worktree switch <full-path>"
            else
                echo "üí° From root, use:"
                echo "   - Root worktree: claude-worktree switch <name>"
                echo "   - Nested worktree: claude-worktree switch <parent>/<child>"
            fi
            echo ""
            echo "Available worktrees:"
            list_worktrees
            exit 1
        fi
    fi
    
    if [ ! -d "$worktree_dir" ]; then
        echo "‚ùå Worktree directory not found: $worktree_dir"
        exit 1
    fi
    
    echo "üîÑ Switching to worktree: $identifier"
    echo "üìÅ Directory: $worktree_dir"
    
    cd "$worktree_dir" && echo "üöÄ Starting Claude Code..." && claude
}

# Create new worktree
create_worktree() {
    local identifier="$1"
    
    if [ -z "$identifier" ]; then
        echo "Usage: claude-worktree worktree <identifier>"
        echo "Example: claude-worktree worktree netflix-clone"
        exit 1
    fi
    
    check_git_repo
    
    local worktree_dir
    local branch_name
    local full_path
    
    # Determine worktree location and branch name based on context
    if [ "$IN_WORKTREE" = "true" ]; then
        # We're in a worktree - create nested worktree
        local parent_name=$(basename $(pwd))
        worktree_dir="$WORKTREE_BASE/$identifier"
        branch_name="feature/kurotaka-claude/${parent_name}--${identifier}"
        full_path="$parent_name/$identifier"
        mkdir -p "$WORKTREE_BASE"
        echo "Creating nested worktree in: $worktree_dir"
        echo "Parent worktree: $parent_name"
        echo "Full path: $full_path"
    else
        # Normal worktree creation
        worktree_dir="$WORKTREE_BASE/$identifier"
        branch_name="feature/kurotaka-claude/$identifier"
        full_path="$identifier"
        echo "Creating worktree: $worktree_dir"
    fi
    
    echo "Branch: $branch_name"
    
    # Check if worktree already exists
    if git worktree list | grep -q "$worktree_dir\s"; then
        echo "‚ö†Ô∏è  Worktree '$identifier' already exists"
        if [ "$IN_WORKTREE" = "true" ]; then
            echo "Use 'claude-worktree switch $full_path' to switch to it"
        else
            echo "Use 'claude-worktree switch $identifier' to switch to it"
        fi
        exit 1
    fi
    
    # Create worktree
    git worktree add "$worktree_dir" -b "$branch_name"
    
    if [ $? -eq 0 ]; then
        echo "‚úÖ Worktree created successfully"
        echo "üìÅ Directory: $worktree_dir"
        echo "üåø Branch: $branch_name"
        
        if [ "$IN_WORKTREE" = "true" ]; then
            echo "üîó Full path: $full_path"
        fi
        
        echo ""
        echo "Moving to worktree directory..."
        cd "$worktree_dir"
        
        echo "üöÄ Starting Claude Code..."
        claude
    else
        echo "‚ùå Failed to create worktree"
        exit 1
    fi
}

# Main command dispatcher
case "$1" in
    "worktree")
        create_worktree "$2"
        ;;
    "list")
        list_worktrees
        ;;
    "switch")
        switch_worktree "$2"
        ;;
    "help"|"--help"|"-h"|"")
        show_help
        ;;
    *)
        echo "Unknown command: $1"
        echo "Use 'claude-worktree help' for usage information"
        exit 1
        ;;
esac