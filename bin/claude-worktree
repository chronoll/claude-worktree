#!/bin/bash

# Claude Tools CLI
# Usage: claude-tools <command> [options]

# Get repository information
get_repo_info() {
    local git_root
    git_root=$(git rev-parse --show-toplevel 2>/dev/null)
    
    if [ -z "$git_root" ]; then
        echo "Error: Not in a git repository"
        exit 1
    fi
    
    # Check if we're in the main repository or a worktree
    local current_dir=$(pwd)
    local main_repo_dir
    
    # Get the main repository directory from git worktree list
    main_repo_dir=$(git worktree list | head -1 | awk '{print $1}')
    
    if [ "$current_dir" = "$main_repo_dir" ]; then
        # We're in the main repository
        REPO_NAME=$(basename "$main_repo_dir")
        WORKTREE_BASE="../project-claude-${REPO_NAME}"
        IN_WORKTREE=false
    else
        # We're in a worktree - check if current directory is a worktree
        if git worktree list | grep -q "^${current_dir}\s"; then
            # We're in a worktree
            REPO_NAME=$(basename "$main_repo_dir")
            WORKTREE_BASE="./worktrees"
            IN_WORKTREE=true
            MAIN_REPO_DIR="$main_repo_dir"
        else
            # We're in a subdirectory - use normal logic
            REPO_NAME=$(basename "$git_root")
            WORKTREE_BASE="../project-claude-${REPO_NAME}"
            IN_WORKTREE=false
        fi
    fi
}

# Check if we're in a git repository
check_git_repo() {
    get_repo_info
}

# Show help message
show_help() {
    echo "Claude Worktree CLI - Worktree management for Claude Code"
    echo ""
    echo "Usage:"
    echo "  claude-worktree worktree <identifier>    Create new worktree and start Claude Code"
    echo "  claude-worktree list                     List all worktrees for this repository"
    echo "  claude-worktree switch <identifier>      Switch to existing worktree"
    echo "  claude-worktree apply                    Apply current changes to parent branch"
    echo "  claude-worktree help                     Show this help message"
    echo ""
    echo "Examples:"
    echo "  claude-worktree worktree netflix-clone   # Create and start new worktree"
    echo "  claude-worktree list                     # Show all worktrees"
    echo "  claude-worktree switch netflix-clone     # Switch to existing worktree"
    echo "  claude-worktree apply                    # Apply changes to parent branch"
}

# List worktrees for this repository with hierarchical display
list_worktrees() {
    check_git_repo
    
    echo "üìã Worktrees for repository: $REPO_NAME"
    echo ""
    
    # Get all worktrees from git, filtering out prunable ones and checking existence
    local valid_worktrees=""
    local temp_file=$(mktemp)
    git worktree list | tail -n +2 | grep -v " prunable" > "$temp_file"
    
    while IFS= read -r line; do
        [ -z "$line" ] && continue
        local worktree_path=$(echo "$line" | awk '{print $1}')
        # Only include worktrees that actually exist on disk
        if [ -d "$worktree_path" ]; then
            valid_worktrees+="$line"$'\n'
        fi
    done < "$temp_file"
    
    rm -f "$temp_file"
    
    if [ -z "$valid_worktrees" ]; then
        echo "No valid worktrees found. Create one with: claude-worktree worktree <identifier>"
        return
    fi
    
    # First, collect all worktrees and identify parent-child relationships
    local temp_output_file=$(mktemp)
    local displayed_parents_file=$(mktemp)
    
    # Process nested worktrees first to identify parents
    echo "$valid_worktrees" | while IFS= read -r line; do
        [ -z "$line" ] && continue
        local worktree_path=$(echo "$line" | awk '{print $1}')
        local branch=$(echo "$line" | awk '{print $3}' | tr -d '[]')
        local identifier=$(basename "$worktree_path")
        
        # Check if this is a nested worktree
        if [[ "$worktree_path" == */worktrees/* ]]; then
            # Extract parent worktree path
            local parent_path=$(echo "$worktree_path" | sed 's|/worktrees/.*||')
            local parent_name=$(basename "$parent_path")
            
            # Check if parent was already shown
            if ! grep -q "^${parent_name}$" "$displayed_parents_file" 2>/dev/null; then
                # Show parent worktree only if it exists in our valid list
                local parent_line=$(echo "$valid_worktrees" | grep "^${parent_path}\s")
                if [ -n "$parent_line" ]; then
                    local parent_branch=$(echo "$parent_line" | awk '{print $3}' | tr -d '[]')
                    echo "üåø $parent_name -> $parent_branch" >> "$temp_output_file"
                    echo "$parent_name" >> "$displayed_parents_file"
                fi
            fi
            
            # Show nested worktree with indentation and full path
            echo "  ‚îî‚îÄ‚îÄ üåø $parent_name/$identifier -> $branch" >> "$temp_output_file"
        fi
    done
    
    # Then process root level worktrees (non-nested)
    echo "$valid_worktrees" | while IFS= read -r line; do
        [ -z "$line" ] && continue
        local worktree_path=$(echo "$line" | awk '{print $1}')
        local branch=$(echo "$line" | awk '{print $3}' | tr -d '[]')
        local identifier=$(basename "$worktree_path")
        
        # Skip nested worktrees (already processed above)
        if [[ "$worktree_path" == */worktrees/* ]]; then
            continue
        fi
        
        # Check if this worktree has nested children
        local has_children=false
        if echo "$valid_worktrees" | grep -q "${worktree_path}/worktrees/"; then
            has_children=true
        fi
        
        # Only show root-level worktrees that don't have children (or parents already shown)
        if [ "$has_children" = "false" ]; then
            # Check if this was already displayed as a parent
            if ! grep -q "^${identifier}$" "$displayed_parents_file" 2>/dev/null; then
                echo "üåø $identifier -> $branch" >> "$temp_output_file"
            fi
        fi
    done
    
    # Output the results and cleanup
    cat "$temp_output_file" 2>/dev/null || echo "No worktrees found."
    rm -f "$temp_output_file" "$displayed_parents_file"
}

# Switch to existing worktree
switch_worktree() {
    local identifier="$1"
    
    if [ -z "$identifier" ]; then
        echo "Usage: claude-worktree switch <identifier>"
        echo "       claude-worktree switch <parent>/<child>  # for nested worktrees"
        echo "Use 'claude-worktree list' to see available worktrees"
        exit 1
    fi
    
    check_git_repo
    
    # Find worktree by identifier from git worktree list
    local worktree_dir
    local matches=()
    local main_repo_base="../project-claude-${REPO_NAME}"
    
    # Check if identifier contains a slash (hierarchical path)
    if [[ "$identifier" == *"/"* ]]; then
        # Hierarchical path - look for exact nested worktree match
        local parent_name=$(echo "$identifier" | cut -d'/' -f1)
        local child_name=$(echo "$identifier" | cut -d'/' -f2-)
        
        # Find the nested worktree - must match exact hierarchy
        worktree_dir=$(git worktree list | grep -E "/$parent_name/worktrees/$child_name\s" | awk '{print $1}' | head -1)
        
        if [ -z "$worktree_dir" ]; then
            echo "‚ùå Nested worktree '$identifier' not found"
            echo "Available worktrees:"
            list_worktrees
            echo ""
            echo "üí° Use exact hierarchical path: parent/child"
            exit 1
        fi
    else
        # Simple identifier - check context-aware matching
        check_git_repo
        
        # Check if we're currently in a worktree
        local current_dir=$(pwd)
        local current_worktree=""
        
        # Find current worktree from git worktree list (exact match)
        local main_repo_path=$(git worktree list | head -1 | awk '{print $1}')
        
        if [[ "$current_dir" == "$main_repo_path" ]]; then
            # We're in main repo, not in a worktree
            current_worktree=""
        else
            while IFS= read -r line; do
                local path=$(echo "$line" | awk '{print $1}')
                if [[ "$current_dir" == "$path" ]]; then
                    current_worktree="$path"
                    break
                fi
            done < <(git worktree list | tail -n +2)  # Skip main repo
        fi
        
        if [ -n "$current_worktree" ]; then
            # We're in a worktree - look for child worktrees first
            local current_name=$(basename "$current_worktree")
            local child_path="$current_worktree/worktrees/$identifier"
            
            if git worktree list | grep -q "$child_path\s"; then
                worktree_dir="$child_path"
                echo "üîó Found child worktree in current context"
            fi
        fi
        
        # If not found in current context, look for root-level worktrees
        if [ -z "$worktree_dir" ]; then
            while IFS= read -r line; do
                local path=$(echo "$line" | awk '{print $1}')
                local path_name=$(basename "$path")
                # Check if this matches the identifier and is a root-level worktree (not nested)
                if [[ "$path_name" == "$identifier" && ! "$path" == */worktrees/* ]]; then
                    matches+=("$path")
                fi
            done < <(git worktree list | tail -n +2)  # Skip main repo
            
            if [ ${#matches[@]} -eq 1 ]; then
                worktree_dir="${matches[0]}"
            elif [ ${#matches[@]} -gt 1 ]; then
                echo "‚ùå Multiple worktrees found for '$identifier':"
                for match in "${matches[@]}"; do
                    echo "   - $match"
                done
                echo ""
                echo "üí° Use full path to specify exact worktree"
                exit 1
            fi
        fi
        
        # Final check if nothing found
        if [ -z "$worktree_dir" ]; then
            echo "‚ùå Worktree '$identifier' not found"
            echo ""
            if [ -n "$current_worktree" ]; then
                local current_name=$(basename "$current_worktree")
                echo "üí° From $current_name, you can:"
                echo "   - Switch to child: claude-worktree switch <child-name>"
                echo "   - Switch to other: claude-worktree switch <full-path>"
            else
                echo "üí° From root, use:"
                echo "   - Root worktree: claude-worktree switch <name>"
                echo "   - Nested worktree: claude-worktree switch <parent>/<child>"
            fi
            echo ""
            echo "Available worktrees:"
            list_worktrees
            exit 1
        fi
    fi
    
    if [ ! -d "$worktree_dir" ]; then
        echo "‚ùå Worktree directory not found: $worktree_dir"
        exit 1
    fi
    
    echo "üîÑ Switching to worktree: $identifier"
    echo "üìÅ Directory: $worktree_dir"
    
    # Open new iTerm2 tab with split panes if running in iTerm2, otherwise use current tab
    if [ "$TERM_PROGRAM" = "iTerm.app" ]; then
        echo "üöÄ Opening new iTerm2 tab with split panes..."
        echo "üìÇ Top pane: Terminal in $worktree_dir"
        echo "ü§ñ Bottom pane: Claude Code"
        
        # Convert to absolute path
        local abs_worktree_dir=$(cd "$worktree_dir" && pwd)
        
        osascript << EOF
tell application "iTerm2"
    tell current window
        create tab with default profile
        tell current session of current tab
            -- Set up top pane (terminal)
            write text "cd '$abs_worktree_dir'"
            write text "echo 'üìÇ Terminal ready in worktree: \$(basename \"$abs_worktree_dir\")'"
            
            -- Split horizontally to create bottom pane
            split horizontally with default profile
        end tell
        
        -- Configure bottom pane (claude)
        tell last session of current tab
            write text "cd '$abs_worktree_dir'"
            write text "claude"
        end tell
    end tell
end tell
EOF
    else
        echo "üöÄ Starting Claude Code..."
        cd "$worktree_dir" && claude
    fi
}

# Create new worktree
create_worktree() {
    local identifier="$1"
    
    if [ -z "$identifier" ]; then
        echo "Usage: claude-worktree worktree <identifier>"
        echo "Example: claude-worktree worktree netflix-clone"
        exit 1
    fi
    
    check_git_repo
    
    local worktree_dir
    local branch_name
    local full_path
    
    # Determine worktree location and branch name based on context
    if [ "$IN_WORKTREE" = "true" ]; then
        # We're in a worktree - create nested worktree
        local parent_name=$(basename $(pwd))
        worktree_dir="$WORKTREE_BASE/$identifier"
        branch_name="feature/kurotaka-claude/${parent_name}--${identifier}"
        full_path="$parent_name/$identifier"
        mkdir -p "$WORKTREE_BASE"
        echo "Creating nested worktree in: $worktree_dir"
        echo "Parent worktree: $parent_name"
        echo "Full path: $full_path"
    else
        # Normal worktree creation
        worktree_dir="$WORKTREE_BASE/$identifier"
        branch_name="feature/kurotaka-claude/$identifier"
        full_path="$identifier"
        echo "Creating worktree: $worktree_dir"
    fi
    
    echo "Branch: $branch_name"
    
    # Check if worktree already exists
    if git worktree list | grep -q "$worktree_dir\s"; then
        echo "‚ö†Ô∏è  Worktree '$identifier' already exists"
        if [ "$IN_WORKTREE" = "true" ]; then
            echo "Use 'claude-worktree switch $full_path' to switch to it"
        else
            echo "Use 'claude-worktree switch $identifier' to switch to it"
        fi
        exit 1
    fi
    
    # Create worktree
    git worktree add "$worktree_dir" -b "$branch_name"
    
    if [ $? -eq 0 ]; then
        echo "‚úÖ Worktree created successfully"
        echo "üìÅ Directory: $worktree_dir"
        echo "üåø Branch: $branch_name"
        
        # Get absolute path before changing directory
        local abs_worktree_dir=$(cd "$worktree_dir" && pwd)
        
        # Record parent branch in git config
        local parent_branch=$(git branch --show-current)
        cd "$worktree_dir"
        git config --local worktree.parent-branch "$parent_branch"
        echo "üìå Parent branch recorded: $parent_branch"
        
        if [ "$IN_WORKTREE" = "true" ]; then
            echo "üîó Full path: $full_path"
        fi
        
        echo ""
        
        # Open new iTerm2 tab with split panes if running in iTerm2, otherwise use current tab
        if [ "$TERM_PROGRAM" = "iTerm.app" ]; then
            echo "üöÄ Opening new iTerm2 tab with split panes..."
            echo "üìÇ Top pane: Terminal in $worktree_dir"
            echo "ü§ñ Bottom pane: Claude Code"
            
            osascript << EOF
tell application "iTerm2"
    tell current window
        create tab with default profile
        tell current session of current tab
            -- Set up top pane (terminal)
            write text "cd '$abs_worktree_dir'"
            write text "echo 'üìÇ Terminal ready in worktree: \$(basename \"$abs_worktree_dir\")'"
            
            -- Split horizontally to create bottom pane
            split horizontally with default profile
        end tell
        
        -- Configure bottom pane (claude)
        tell last session of current tab
            write text "cd '$abs_worktree_dir'"
            write text "claude"
        end tell
    end tell
end tell
EOF
        else
            echo "üöÄ Starting Claude Code..."
            cd "$worktree_dir" && claude
        fi
    else
        echo "‚ùå Failed to create worktree"
        exit 1
    fi
}

# Apply current worktree changes to parent branch
apply_to_parent() {
    check_git_repo
    
    # Get current branch
    local current_branch=$(git branch --show-current)
    if [ -z "$current_branch" ]; then
        echo "‚ùå Not on a branch (detached HEAD state)"
        exit 1
    fi
    
    # Get parent branch from git config
    local parent_branch=$(git config --local worktree.parent-branch)
    
    if [ -z "$parent_branch" ]; then
        echo "‚ùå No parent branch found in git config"
        echo ""
        echo "This might happen if:"
        echo "1. This worktree was created before the parent tracking feature"
        echo "2. The worktree was created manually without claude-worktree"
        echo ""
        echo "You can manually set the parent branch:"
        echo "  git config --local worktree.parent-branch <parent-branch-name>"
        exit 1
    fi
    
    echo "üîç Current branch: $current_branch"
    echo "üéØ Parent branch: $parent_branch"
    echo ""
    
    # Check if parent branch exists
    if ! git show-ref --verify --quiet "refs/heads/$parent_branch"; then
        echo "‚ùå Parent branch '$parent_branch' does not exist"
        echo "Available branches:"
        git branch -a
        exit 1
    fi
    
    # Check for uncommitted changes
    if ! git diff-index --quiet HEAD --; then
        echo "‚ùå You have uncommitted changes. Please commit or stash them first."
        git status --short
        exit 1
    fi
    
    # Find parent worktree directory
    local parent_worktree_dir=""
    while IFS= read -r line; do
        local worktree_path=$(echo "$line" | awk '{print $1}')
        local worktree_branch=$(echo "$line" | awk '{print $3}' | tr -d '[]')
        if [ "$worktree_branch" = "$parent_branch" ]; then
            parent_worktree_dir="$worktree_path"
            break
        fi
    done < <(git worktree list)
    
    if [ -z "$parent_worktree_dir" ]; then
        echo "‚ùå Parent branch '$parent_branch' is not checked out in any worktree"
        echo "Please ensure the parent branch has an active worktree."
        exit 1
    fi
    
    echo "üìÅ Parent worktree: $parent_worktree_dir"
    
    # Fetch latest changes
    echo "üì• Fetching latest changes..."
    git fetch origin
    
    # Get merge strategy from user
    echo ""
    echo "Select merge strategy:"
    echo "1) Fast-forward only (--ff-only)"
    echo "2) Create merge commit (--no-ff)"
    echo "3) Cancel"
    read -p "Choice [1-3]: " choice
    
    local merge_flags=""
    case "$choice" in
        1)
            merge_flags="--ff-only"
            ;;
        2)
            merge_flags="--no-ff"
            ;;
        3)
            echo "‚ùå Apply cancelled"
            exit 0
            ;;
        *)
            echo "‚ùå Invalid choice"
            exit 1
            ;;
    esac
    
    # Execute merge in parent worktree
    echo ""
    echo "üîÑ Applying changes in parent worktree..."
    echo "Running: cd $parent_worktree_dir && git merge $merge_flags $current_branch"
    
    # Save current directory
    local current_dir=$(pwd)
    
    # Change to parent worktree and perform merge
    cd "$parent_worktree_dir"
    git merge $merge_flags "$current_branch"
    local merge_result=$?
    
    # Return to original directory
    cd "$current_dir"
    
    if [ $merge_result -eq 0 ]; then
        echo ""
        echo "‚úÖ Changes applied successfully!"
        echo ""
        echo "Next steps:"
        echo "1. Review changes in parent worktree: cd $parent_worktree_dir"
        echo "2. Push to remote: cd $parent_worktree_dir && git push origin $parent_branch"
        echo "3. Continue working in current worktree"
    else
        echo ""
        echo "‚ùå Apply failed or has conflicts"
        echo ""
        echo "To resolve:"
        echo "1. Go to parent worktree: cd $parent_worktree_dir"
        echo "2. Fix conflicts: git status"
        echo "3. Complete merge: git add . && git commit"
        echo "4. Or abort: git merge --abort"
    fi
}

# Main command dispatcher
case "$1" in
    "worktree")
        create_worktree "$2"
        ;;
    "list")
        list_worktrees
        ;;
    "switch")
        switch_worktree "$2"
        ;;
    "apply")
        apply_to_parent
        ;;
    "help"|"--help"|"-h"|"")
        show_help
        ;;
    *)
        echo "Unknown command: $1"
        echo "Use 'claude-worktree help' for usage information"
        exit 1
        ;;
esac